/*
                    switch(number) {

                        case 1:
                            tankE->direction = 'H';
                            if(isFree(map, tankE) ){
                                
                                deleteTank(tankE, map);
                                
                                replaceMatrixToAnother(tankH_ts, tankE->carrosserie);
                                tankE->posX--;
                                moveTank(tankE, map);
                            }
                             break;
                    
                        case 2:
                            
                            tankE->direction = 'B';
                            if(isFree(map, tankE)){
                                deleteTank(tankE, map);
                                replaceMatrixToAnother(tankB_ts, tankE->carrosserie);
                                
                                tankE->posX++;
                                moveTank(tankE, map);
                                
                            }
                             break;
                        case 3:
                                
                                tankE->direction = 'D';
                                if((isFree(map, tankE))){

                                    deleteTank(tankE, map);
                                    replaceMatrixToAnother(tankD_ts, tankE->carrosserie);
                                    tankE->posY++;
                                    moveTank(tankE, map);
                                }
                                 break;
                        
                        case 4:
                                tankE->direction = 'G';
                                if(isFree(map, tankE)) {
                                    
                                    deleteTank(tankE, map);
                                    replaceMatrixToAnother(tankG_ts, tankE->carrosserie);
                                    
                                    tankE->posY--;
                                    moveTank(tankE, map);
                                
                                }
                                 break;
                    }
                    */


                    
                    /*Vérification fonctionnement liste */
    Tank *t = malloc(1*sizeof(Tank));
    Tank *t2 = malloc(1*sizeof(Tank));
    Tank *t3 = malloc(1*sizeof(Tank));
    Tank *t4 = malloc(1*sizeof(Tank));
    Tank *t5 = malloc(1*sizeof(Tank));
    Tank *t6 = malloc(1*sizeof(Tank));
    Tank *t7 = malloc(1*sizeof(Tank));

    t = initTankPlayer(t);
    t2 = initTankEnemy(t2);
    t3 = initTankEnemy(t3);
    t4 = initTankEnemy(t4);
    t5 = initTankEnemy(t5);
    t6 = initTankEnemy(t6);
    t7 = initTankEnemy(t7);

    TankList *maListeDeTanks = initTankList(t);

    insertNewTank(maListeDeTanks, t);
    insertNewTank(maListeDeTanks, t2);
    insertNewTank(maListeDeTanks, t3);
    insertNewTank(maListeDeTanks, t4);
    insertNewTank(maListeDeTanks, t5);
    insertNewTank(maListeDeTanks, t6);
    insertNewTank(maListeDeTanks, t7);

    dispTankList(maListeDeTanks);

    deleteFirstTank(maListeDeTanks);
    dispTankList(maListeDeTanks);

    deleteTankById(maListeDeTanks, 3);
    dispTankList(maListeDeTanks);

      /*  int posX=0, posY=0;
   Obus *obus = malloc(1*sizeof(Obus)); 
   if(tank->type == 'P')
        obus->type='P';
    else
        obus->type='E';

   obus->caractere = 'O';
   
   switch(tank->direction){
       case 'H':
            obus->posY=(tank->posY)+4;
            posY = obus->posY;
            obus->posX = (tank->posX)-1;

            for(posX=(tank->posX)-1; posX<(nbLineMap - (tank->posX)-1); posX--){
                if(map[posX][posY]==' '){
                    moveObus(obus, map);
                    deleteObus(obus, map);
                }
                else{
                    map[posX][posY]= ' ';
                    printf("%c", map[posX][posY]);
                    break;
                }
                obus->posX = posX;
            }
            break;
       case 'B':
            obus->posY=(tank->posY)+4;
            posY = obus->posY;
            obus->posX = (tank->posX)+nbLineTank+1;

            for(posX=((tank->posX)+nbLineTank+1); posX<(nbLineMap - (tank->posX)+nbLineTank+1); posX++){
                if(map[posX][posY]==' '){
                    moveObus(obus, map);
                    deleteObus(obus, map);
                }
                else{
                    map[posX][posY]= ' ';
                    printf("%c",map[posX][posY]);
                    break;
                }
                obus->posX = posX;
            }

            break;
        case 'G':
            obus->posX=(tank->posY)+2; // canon
            posX = obus->posX;
            obus->posY=(tank->posY)-1;

            for(posY=((tank->posY)-1); posY<(nbColMap - (tank->posY)-1 ); posY--){
                if(map[posX][posY]==' '){
                    map[posX][posY]= obus->caractere;
                    printf("%c", map[posX][posY]);

                    map[posX][posY+1]=' ';
                    //Ici - car on descend
                    printf("%c", map[posX][posY+1]);
                }
                else{
                    map[posX][posY]= ' ';
                    printf("%c",map[posX][posY]);
                    break;
                }
                obus->posY = posY;
            }
            break;
       case 'D':
            obus->posX=(tank->posY)+2; // canon
            posX = obus->posX;

            obus->posY=(tank->posY)+nbColTank+1;

            for(posY=((tank->posY)+nbColTank+1); posY<(nbColMap - ((tank->posY)+nbColTank+1) ); posY++){
                if(map[posX][posY]==' '){
                    moveObus(obus, map);
                    deleteObus(obus, map);
                    /*
                    map[posX][posY]= obus->caractere;
                    printf("%c", map[posX][posY]);

                    map[posX][posY-1]=' ';
                    //Ici - car on descend
                    printf("%c", map[posX][posY-1]);
                    
                }
                else{
                    map[posX][posY]= ' ';
                    printf("%c",map[posX][posY]);
                    break;
                }
                obus->posY = posY;
            }
            break;
     }
*/


void moveObus(Obus *obus, char **map){
    map[obus->posX][obus->posY]=obus->caractere;
    printf("%c", map[obus->posX][obus->posY]);
}

void deleteObus(Obus *obus, char **map){
    map[obus->posX][obus->posY]=' ';
    printf("%c", map[obus->posX][obus->posY]);
}

void testMatrix(char **mat, int nbL, int nbC){
    int i, j;

    for(i=0; i<nbLineMap; i++){
        for(j=0; j<nbColMap; j++){
            mat[i][j]=' ';
        }
    }
}


void deleteTankById(TankList *list, int id){
    if(list == NULL)
        exit(EXIT_FAILURE);
    Tank *first = list->firstTank;
    Tank *toDelete;
    while(first != NULL){
        if(first->id == id){
            toDelete = first;
            list->firstTank = list->firstTank->next;
            free(toDelete);
            break;
        }
        first = first->next;
    }
}

void deleteObusById(ObusList *list, int id){
    if(list == NULL)
        exit(EXIT_FAILURE);
    Obus *first = list->firstObus;
    Obus *toDelete;
    while(first != NULL){
        if(first->id == id){
            toDelete = first;
            list->firstObus = list->firstObus->next;
            free(toDelete);
            break;
        }
        first = first->next;
    }
}

	case 'H':
			if(map[posX-1][posY] != ' '){
                //damage_tank(t, map[o->posX--][o->posY], o, tList, map);
                //checkIfPiouPiouIsAlright(map[o->posX--][o->posY]);
                changeBlock(map, o);
				/*if map à cette pos correspond à un truc tank damage tank pour la vie
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
				printf(" ");
                */
				//gérer dégats
                deleteFirstObus(obusList);
                
			}else{
				map[o->posX][o->posY] = ' ';
				moveToPosXY(posX-1, o->posY);
				printf(" ");
			}
			break;
		case 'B':
			if(map[o->posX++][o->posY] != ' '){
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
				printf(" ");
				deleteFirstObus(obusList);
				//gérer dégats
			}else{
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
				printf(" ");
			}
			break;
	
        case 'G':
			if(map[posX][posY-1] != ' '){
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
				printf(" ");
				deleteFirstObus(obusList);
				//gérer dégats
			}else{
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
					printf(" ");
			}
			break;
		case 'D':
			if(map[o->posX][o->posY++] != ' '){
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
				printf(" ");
				deleteFirstObus(obusList);	
				//gérer dégats
			}else{
				map[o->posX][o->posY] = ' ';
				moveToPosXY(o->posX, o->posY);
				printf(" ");
			}
			break;
		

        (char **tankB_ts, char **tankB_tb, char **tankB_tub,
char **tankG_ts, char **tankG_tb, char **tankG_ub, 
char **map, TankList *tankList, int modeJeu)


//generer pour mode difficile
else if(modeJeu == 2){
        nbTanks = 15;

        do{
            Tank *tank = initTankEnemy(tank);
            randPos = rand()%2-1;
            if(randPos == 1){
                switch(tank->armor){
                        case 1:
                            replaceMatrixWithAnother(tankB_ts,tank->bodyWork);
                            if(!checkIfSpawnIsFree(map, tank->posX, tank->posY))
                                break;
                            else
                                loadTankInMatrix(map,tank);
                            break;
                        case 2:
                            replaceMatrixWithAnother(tankB_tb,tank->bodyWork);
                            if(!checkIfSpawnIsFree(map, tank->posX, tank->posY))
                                break;
                            else
                                loadTankInMatrix(map,tank);
                            break;
                        case 3:
                            replaceMatrixWithAnother(tankB_ts,tank->bodyWork);
                            if(!checkIfSpawnIsFree(map, tank->posX, tank->posY))
                                break;
                            else
                                loadTankInMatrix(map,tank);
                            break;
                }
                tank->direction = 'G';
                tank->posX = posX_droite;
                tank->posY = posY_droite;
            }else{
                tank->direction = 'B';
                tank->posX = posX_haut;
                tank->posY = posY_haut;
                switch(tank->armor){
                        case 1:
                            replaceMatrixWithAnother(tankG_ts,tank->bodyWork);
                            if(!checkIfSpawnIsFree(map, tank->posX, tank->posY))
                                break;
                            else
                                loadTankInMatrix(map,tank);
                            break;
                        case 2:
                            replaceMatrixWithAnother(tankG_tb,tank->bodyWork);
                            if(!checkIfSpawnIsFree(map, tank->posX, tank->posY))
                                break;
                            else
                                loadTankInMatrix(map,tank);
                            break;
                        case 3:
                            replaceMatrixWithAnother(tankG_ts,tank->bodyWork);
                            if(!checkIfSpawnIsFree(map, tank->posX, tank->posY))
                                break;
                            else
                                loadTankInMatrix(map,tank);
                            break;
                }
            }
            insertNewTank(tankList, tank);
            nbTanks--;

        }while(nbTanks != 0);

    }


void moveTank(Tank *tank, char **map){
    int i, j;
    int k=tank->posX, l=tank->posY;

    for(i = 0 ; i < nbLineTank ; i++){
        l=0;
        for(j = 0;  j < nbColTank; j++){

            moveToPosXY(1+tank->posX+i, 1+tank->posY+j);
            switch(tank->bodyWork[k][l]){
                    case '0':
                        printf("\033[37m╔\033[00m");
                        break;
                    case '1':
                        printf("\033[37m╗\033[00m");
                        break;
                    case '2':
                        printf("\033[37m╗\033[00m╝");
                        break;
                    case '3':
                        printf("\033[37m╗\033[00m╚");
                        break;
                    case '-':
                        printf("\033[37m╗\033[00m═");
                        break;
                    case '|':
                        printf("\033[37m╗\033[00m║");
                        break;
                    case 'E':
                        printf("\033[37m▓\033[00m");
                        break;
                    case 'M':
                        printf("▓");
                        break;
                    case 'L':
                        printf("\033[37m_\033[00m");
                        break;
                    case 'T':
                        printf("\033[37m|\033[00m");
                        break;
                    case 'B':
                        printf("\033[37m█\033[00m");
                        break;
                    case 'I':
                        printf("\033[37m▀\033[00m");
                        break;
                    case 'U':
                        printf("\033[37m─\033[00m");
                        break;
                }
            map[k][l] = tank->bodyWork[i][j];
            
            l++;
        }
        k++;
    }
}

/* 
FILE *tb_bas = NULL, *tub_hardmode = NULL, *tub_easyMode = NULL;

    tb_bas = fopen("../models/tanks/deplacement_TB/tb_bas.txt", "r+");
    tub_easyMode = fopen("../models/tanks/deplacement_TUB_easyMode/tub_haut.txt", "r+");
    tub_hardmode = fopen("../models/tanks/deplacement_TUB_hardMode/tub_haut.txt", "r+");
    char **mat1 = matrixAlloc(nbLineTank, nbColTank), **mat2 = matrixAlloc(nbLineTank, nbColTank), **mat3 = matrixAlloc(nbLineTank, 11);
    writingMat(nbLineTank, nbColTank, mat1, tb_bas);
    writingMat(nbLineTank, nbColTank, mat2, tub_easyMode); 
	writingMat(nbLineTank, 11, mat3, tub_easyMode); 

    fclose(tb_bas);
    fclose(tub_easyMode);
    fclose(tub_hardmode);
    system("clear");
     printf("\n\n");
    dispMatrix(nbLineTank, nbColTank, mat1);
    printf("\n\n");
    dispMatrix(nbLineTank, nbColTank, mat2);
     printf("\n\n");
    dispMatrix(nbLineTank, 11, mat3);

    freeMat(nbLineTank, mat1);
    freeMat(nbLineTank, mat2);
    freeMat(nbLineTank, mat3);*/



    //tank qui bouffe tout sur le passage


int changeBlock(char **map, int posX, int posY){
    if(map[posX][posY] == 'R'){

        map[posX][posY] = 'A';
        moveToPosXY(posX, posY);
        printf("\033[31m☎\033[00m");
        return 1;
    }else if(map[posX][posY] == 'A'){

        map[posX][posY] = ' ';
        moveToPosXY(posX, posY);
        printf(" ");

        return 1;
    }
    return 0;
}

void checkIfPiouPiouIsAlright(char c){
    FILE *fgameover = NULL;
    fgameover = fopen("../models/menus/gameover.txt", "r+");

    if(fgameover != NULL){
        if(c == 'K'){
            system("clear");
            dispFile(fgameover);

            fclose(fgameover);
            exit(0);
        }
    }
}

switch(o->direction){
        
        case 'H':
             if(map[oldx-1][oldy] == ' '){
                moveToPosXY(o->posX, o->posY);
                printf(" ");
                map[o->posX][o->posY] = ' ';
                
                o->posX--;
                moveToPosXY(o->posX, o->posY);
                printf("✴");
                map[o->posX][o->posY]=o->caractere;

            }
            else{
                /*damage_tank(t, map[posX-1][posY], o, tList, map) ||*/ 
                
                moveToPosXY(o->posX, o->posY);
                //printf(" ");
                map[o->posX][o->posY] = ' ';
                o->posX--;
                moveToPosXY(1,1);
                printf("%c", map[o->posX][o->posY]);
                exit(-1);
                if(changeBlock(map, o))
                    deleteObusById(obusList, o->id, map);
                checkIfPiouPiouIsAlright(map[o->posX-1][o->posY]);
            }
            break;
        case 'B':
             if(map[o->posX+1][o->posY] == ' '){
                moveToPosXY(o->posX, o->posY);
                printf(" ");
                map[o->posX][o->posY] = ' ';
                
                o->posX++;
                moveToPosXY(o->posX, o->posY);
                printf("✴");
                map[o->posX][o->posY]=o->caractere;
                

                
            }
            else{
                o->posX++;
                if(changeBlock(map, o))
                    deleteObusById(obusList, o->id,map);
                checkIfPiouPiouIsAlright(map[o->posX+1][o->posY]);
                
            }
            break;
        case 'G':
             if(map[o->posX][o->posY-1] == ' '){
                moveToPosXY(o->posX, o->posY);
                printf(" ");
                map[o->posX][o->posY] = ' ';
                
                
                o->posY--;
                moveToPosXY(o->posX, o->posY);
                printf("✴");
                map[o->posX][o->posY]=o->caractere;

                
            }
            else{
                o->posY--;
                if(changeBlock(map, o))
                    deleteObusById(obusList, o->id,map);
                checkIfPiouPiouIsAlright(map[o->posX][o->posY-1]);
            }
            break;
        case 'D':
            if(map[o->posX][o->posY+1] == ' '){
                moveToPosXY(o->posX, o->posY);
                map[o->posX][o->posY] = ' ';
                printf(" ");
                
                o->posY++;
                moveToPosXY(o->posX, o->posY);
                map[o->posX][o->posY]=o->caractere;
                printf("✴");

                
            }
            else{
                o->posY++;
                if(changeBlock(map, o))
                    deleteObusById(obusList, o->id,map);
                checkIfPiouPiouIsAlright(map[o->posX][o->posY+1]);
            }
            break;
	}